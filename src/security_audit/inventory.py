"""Utilities to produce prioritized security inventories from JSON data.\n\n"""\n\nfrom __future__ import annotations\n\nimport json\nimport re\nfrom collections import Counter\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Iterable, List, Sequence\n\nPRIORITY_RULES: Sequence[tuple[str, tuple[str, ...]]] = (\n    ("Critical (Secrets)", ("secret", "credential", "password", "api key", "token")),\n    (\n        "High (Transport Security)",\n        ("https", "tls", "transport", "ssl", "hsts", "certificate"),\n    ),\n    (\n        "High (Authentication/Authorization)",\n        ("auth", "jwt", "rbac", "session", "mfa", "authorization"),\n    ),\n)\nPRIORITY_ORDER = {label: index for index, (label, _) in enumerate(PRIORITY_RULES)}\nDEFAULT_PRIORITY = "Medium (General Hardening)"\nTARGET_PREFIXES = ("src/", "scripts/", "nginx/")\nTARGET_FILES = {"docker-compose.yaml"}\n\n@dataclass\nclass InventoryItem:\n    """Represents a single security finding from the batch file."""\n\n    identifier: int\n    problem: str\n    fix_prompt: str\n    affected_files: list[str]\n    priority: str\n\n    @property\n    def area(self) -> str:\n        root = sorted({_derive_area(path) for path in self.affected_files})\n        return ", ".join(root) if root else "n/a"\n\ndef _derive_area(path: str) -> str:\n    if path == "docker-compose.yaml":\n        return "docker-compose"\n    return path.split("/", 1)[0]\n\ndef _normalize_path(raw: str) -> str:\n    return raw.split(":", 1)[0]\n\ndef _is_target_path(path: str) -> bool:\n    if path in TARGET_FILES:\n        return True\n    return any(path.startswith(prefix) for prefix in TARGET_PREFIXES)\n\ndef _determine_priority(problem: str, fix_prompt: str) -> str:\n    haystack = f"{problem} {fix_prompt}".lower()\n    for label, keywords in PRIORITY_RULES:\n        if any(keyword in haystack for keyword in keywords):\n            return label\n    return DEFAULT_PRIORITY\n\ndef _filter_items(raw_items: Iterable[dict]) -> List[InventoryItem]:\n    filtered: List[InventoryItem] = []\n    for entry in raw_items:\n        affected = [_normalize_path(path) for path in entry.get("affected_files", [])]\n        scoped = [path for path in affected if _is_target_path(path)]\n        if not scoped:\n            continue\n\n        # Handle malformed or missing IDs gracefully\n        id_raw = entry.get("id")\n        try:\n            identifier = int(id_raw)\n        except (TypeError, ValueError):\n            # Skip items that do not have a valid integer ID\n            continue\n\n        priority = _determine_priority(entry.get("problem", ""), entry.get("fix_prompt", ""))\n\n        filtered.append(\n            InventoryItem(\n                identifier=identifier,\n                problem=entry.get("problem", "Unknown problem"),\n                fix_prompt=entry.get("fix_prompt", ""),\n                affected_files=sorted(set(scoped)),\n                priority=priority,\n            )\n        )\n    return filtered\n\ndef _sort_items(items: Sequence[InventoryItem]) -> List[InventoryItem]:\n    def sort_key(item: InventoryItem) -> tuple[int, int]:\n        priority_rank = PRIORITY_ORDER.get(item.priority, len(PRIORITY_RULES))\n        return (priority_rank, item.identifier)\n\n    return sorted(items, key=sort_key)\n\ndef generate_inventory_markdown(json_path: Path) -> str:\n    """Generate a markdown table with prioritized issues from the JSON file."""\n\n    data = json.loads(json_path.read_text())\n    problems = data.get("security_problems", {}).get("problems", [])\n    items = _filter_items(problems)\n    if not items:\n        return "# Security Inventory – Batch 1\n\nNo scoped issues were detected."\n\n    items = _sort_items(items)\n\n    counts = Counter(item.priority for item in items)\n    summary_lines = ["## Prioritization Summary\n"]\n    for label, _ in PRIORITY_RULES:\n        if label in counts:\n            summary_lines.append(f"- **{label}:** {counts[label]} findings")\n    if DEFAULT_PRIORITY in counts:\n        summary_lines.append(f"- **{DEFAULT_PRIORITY}:** {counts[DEFAULT_PRIORITY]} findings")\n\n    header = [\n        "# Security Inventory – Batch 1",\n        "",\n        "This report inventories findings from `security_problems_batch1.json`",\n        "with scope limited to `src/`, `scripts/`, `nginx/`, and `docker-compose.yaml`.",\n        "Findings are prioritized by exploitability, emphasizing secrets, transport",\n        "security, and authentication/authorization weaknesses.",\n        "",\n    ]\n\n    table_header = (\n        "| Priority | ID | Area | Problem | Key Files | Recommended Actions |\n"\n        "| --- | --- | --- | --- | --- | --- |"\n    )\n    rows = []\n    for item in items:\n        key_files = "<br/>".join(item.affected_files)\n        fix_prompt = re.sub(r"\s+", " ", item.fix_prompt.strip())\n        row = (\n            f"| {item.priority} | {item.identifier} | {item.area} | {item.problem} | "\n            f"{key_files} | {fix_prompt} |"\n        )\n        rows.append(row)\n\n    body = ["## Detailed Findings", "", table_header, *rows]\n\n    return "\n".join(header + summary_lines + [""] + body) + "\n"\n\ndef write_inventory_markdown(json_path: Path, output_path: Path) -> None:\n    """Write the generated markdown inventory to disk."""\n\n    markdown = generate_inventory_markdown(json_path)\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    output_path.write_text(markdown)\n\nif __name__ == "__main__":  # pragma: no cover - manual execution helper\n    write_inventory_markdown(\n        Path("security_problems_batch1.json"),\n        Path("docs/security/security_inventory_batch1.md"),\n    )\n