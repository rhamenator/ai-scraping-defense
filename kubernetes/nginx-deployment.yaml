# kubernetes/nginx-deployment.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  namespace: ai-defense
# ... (nginx.conf, check_blocklist.lua, detect_bot.lua content remains the same as in k8s_nginx_deployment_namespaced) ...
# --- Make sure the Lua scripts here are the latest corrected versions ---
data:
  nginx.conf: |
    user www-data; # Nginx worker processes will run as www-data
    worker_processes auto;
    pid /run/nginx.pid; # Needs to be writable by root (master process) or www-data if master also non-root
    include /etc/nginx/modules-enabled/*.conf;

    events {
        worker_connections 1024;
    }

    http {
        # ... (rest of http block from k8s_nginx_deployment_namespaced) ...
        # Ensure log paths like /var/log/nginx/ are writable by www-data
        # or use a volume mount that www-data can write to.
        # Default Nginx images often handle this.
        access_log /var/log/nginx/access.log detailed;
        error_log /var/log/nginx/error.log warn;
        # ... (rest of http block) ...
        server {
            # ... (rest of server block from k8s_nginx_deployment_namespaced) ...
            # Ensure root /usr/share/nginx/html and alias paths are accessible
        }
    }
  check_blocklist.lua: |
    # --- PASTE CORRECTED check_blocklist.lua content here ---
    # --- (from Immersive ID: check_blocklist_lua_corrected) ---
    local redis_host = os.getenv("REDIS_HOST") or "redis.ai-defense.svc.cluster.local"
    local redis_port = tonumber(os.getenv("REDIS_PORT")) or 6379
    local redis_db_blocklist = tonumber(os.getenv("REDIS_DB_BLOCKLIST")) or 2
    local redis_blocklist_key_prefix = "blocklist:ip:"
    local redis_timeout_ms = 200
    local remote_addr = ngx.var.remote_addr
    if not remote_addr then ngx.log(ngx.WARN, "check_blocklist: Could not get remote_addr"); return end
    local redis = require "resty.redis"; local red = redis:new()
    red:set_timeout(redis_timeout_ms)
    local ok, err = red:connect(redis_host, redis_port)
    if not ok then ngx.log(ngx.ERR, "check_blocklist: Failed to connect to Redis: ", err); return end
    local select_ok, select_err = red:select(redis_db_blocklist)
    if not select_ok then ngx.log(ngx.ERR, "check_blocklist: Failed to select Redis DB: ", select_err); red:close(); return end
    local blocklist_ip_key = redis_blocklist_key_prefix .. remote_addr
    local exists, err = red:exists(blocklist_ip_key)
    if err then ngx.log(ngx.ERR, "check_blocklist: Failed to query Redis EXISTS: ", err); red:close(); return end
    local close_ok, close_err = red:set_keepalive(0, 100)
    if not close_ok then ngx.log(ngx.WARN,"check_blocklist: Failed to set Redis keepalive: ", close_err); red:close() end
    if exists == 1 then ngx.log(ngx.WARN, "check_blocklist: Blocking IP ", remote_addr); return ngx.exit(ngx.HTTP_FORBIDDEN) end
    return

  detect_bot.lua: |
    # --- PASTE CORRECTED/UPDATED detect_bot.lua content here ---
    # --- (from Immersive ID: k8s_nginx_deployment_namespaced or your latest) ---
    local bad_bots = { "GPTBot", "CCBot", "Bytespider", "PetalBot", "Scrapy", "python-requests", "curl", "wget" }
    local benign_bots = { "googlebot", "bingbot", "duckduckbot" }
    local live_robots_txt_path = "/etc/nginx/live_robots.txt" 
    local dynamic_disallowed_paths = {}
    local function load_dynamic_robots_rules()
        local file = io.open(live_robots_txt_path, "r")
        if not file then ngx.log(ngx.ERR, "detect_bot: Could not open live_robots.txt at ", live_robots_txt_path); return end
        local current_ua_is_star = false
        for line in file:lines() do
            line = string.lower(string.gsub(line, "^%s*(.-)%s*$", "%1"))
            if string.match(line, "^user%-agent:%s*%*") then current_ua_is_star = true
            elseif string.match(line, "^user%-agent:") then current_ua_is_star = false end
            if current_ua_is_star then
                local disallow_match = string.match(line, "^disallow:%s*(.+)")
                if disallow_match and disallow_match ~= "/" then table.insert(dynamic_disallowed_paths, disallow_match) end
            end
        end
        file:close()
    end
    load_dynamic_robots_rules()
    local function contains_string(str, list) if not str then return false end; local s = string.lower(str); for _, p in ipairs(list) do if string.find(s, string.lower(p), 1, true) then return true, p end end; return false end
    local function is_path_disallowed(path, rules) if not path or not rules then return false end; for _, d in ipairs(rules) do if string.sub(path, 1, string.len(d)) == d then return true end end; return false end
    local ua = ngx.req.get_headers()["User-Agent"]; local ip = ngx.var.remote_addr; local uri = ngx.var.request_uri or "/"
    local real_backend = os.getenv("REAL_BACKEND_HOST")
    local is_benign, _ = contains_string(ua, benign_bots)
    if is_benign then
      if is_path_disallowed(uri, dynamic_disallowed_paths) then
        ngx.log(ngx.WARN, "Benign bot ", ua, " to disallowed path ", uri, ". Tarpitting IP: ", ip)
        return ngx.exec("/api/tarpit")
      end
      ngx.log(ngx.INFO, "Benign bot ", ua, ". Proxying to backend. IP: ", ip)
      if real_backend and real_backend ~= "" then ngx.var.lua_proxy_pass_upstream = real_backend; return ngx.OK end
      return ngx.OK
    end
    local score = 0; if contains_string(ua, bad_bots) then score = score + 0.8 end; if not ua or ua == "" then score = score + 0.4 end
    if score >= 0.7 then ngx.log(ngx.WARN, "High score bot ", ua, ". Tarpitting. IP: ", ip); return ngx.exec("/api/tarpit") end
    ngx.log(ngx.DEBUG, "Request passed bot checks. Proxying to backend. IP: ", ip)
    if real_backend and real_backend ~= "" then ngx.var.lua_proxy_pass_upstream = real_backend; return ngx.OK end
    return ngx.OK
---
# ConfigMap for DH parameters (content from k8s_nginx_deployment_namespaced)
# ... (paste the dhparam-config ConfigMap here) ...
apiVersion: v1
kind: ConfigMap
metadata:
  name: dhparam-config
  namespace: ai-defense
data:
  dhparam.pem: |
    -----BEGIN DH PARAMETERS-----
    REPLACE THIS WITH YOUR SECURELY GENERATED 4096-BIT DH PARAMETERS
    MIIBCAKCAQEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz
    +8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a
    87VXEWT0PU8VLfjrVQMeQaSbPkMCyHWrwZxN/gia/vaMs0ZtXELGduP67AGJTShr
    DWGCZn1J0Yp7qHyxvyYdkJkzaLpAb/+VWdHhDWJgMWBjlHuHYdhMhPymg2mN1fX/
    f+M/TLzVOYSnMA+E4Shc/7ISU/Tt/hEXnvuYRaL+GjN2lsHDerzLxa7+PFHBdXkM
    h+1nCaTWsTuMIKBPfv0QD3aFV4LdLoPGtEpNrtQ9Y+o+pa829A==
    -----END DH PARAMETERS-----
---
# ConfigMap for custom Nginx error pages (content from k8s_nginx_deployment_namespaced)
# ... (paste the nginx-error-pages ConfigMap here) ...
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-error-pages
  namespace: ai-defense
data:
  403_forbidden.html: |
    <!DOCTYPE html><html><head><title>403 Forbidden</title></head><body><h1>403 Forbidden</h1><p>Access denied.</p></body></html>
  404_not_found.html: |
    <!DOCTYPE html><html><head><title>404 Not Found</title></head><body><h1>404 Not Found</h1><p>The requested resource was not found.</p></body></html>
  50x_error.html: |
    <!DOCTYPE html><html><head><title>Server Error</title></head><body><h1>Server Error</h1><p>An internal server error occurred.</p></body></html>
---
apiVersion: v1
kind: Service
metadata:
  name: nginx
  namespace: ai-defense
  # ... (rest of Service definition from k8s_nginx_deployment_namespaced) ...
  labels:
    app: nginx
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 80
      targetPort: http
      name: http
    - protocol: TCP
      port: 443
      targetPort: https
      name: https
  type: LoadBalancer
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  namespace: ai-defense
  # ... (rest of Deployment metadata from k8s_nginx_deployment_namespaced) ...
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      # Pod level security context is usually not needed if container is well-defined,
      # especially as Nginx master runs as root.
      containers:
      - name: nginx
        image: anti-scrape-nginx:v0.1.0 # YOUR BUILT NGINX IMAGE
        imagePullPolicy: IfNotPresent
        securityContext: # Container-level security context for Nginx
          allowPrivilegeEscalation: false # Prevent privilege escalation
          # Nginx master runs as root to bind to ports 80/443 and manage workers.
          # Workers then drop to 'www-data'.
          # capabilities:
          #   drop:
          #     - "ALL"
          #   add: # Only if Nginx itself (not just workers) were to run non-root and bind low ports
          #     - "NET_BIND_SERVICE"
          # readOnlyRootFilesystem: true # Difficult for Nginx due to logs, pid, temp files unless all are on volumes
        ports:
        - containerPort: 80
          name: http
        - containerPort: 443
          name: https
        envFrom:
          - configMapRef:
              name: app-config
        # ... (rest of container spec: resources, volumeMounts, probes from k8s_nginx_deployment_namespaced) ...
        resources:
          requests: { cpu: "150m", memory: "128Mi" }
          limits: { cpu: "500m", memory: "256Mi" }
        volumeMounts:
          - name: nginx-config-volume
            mountPath: /etc/nginx/nginx.conf
            subPath: nginx.conf
            readOnly: true
          - name: nginx-config-volume
            mountPath: /etc/nginx/lua/check_blocklist.lua
            subPath: check_blocklist.lua
            readOnly: true
          - name: nginx-config-volume
            mountPath: /etc/nginx/lua/detect_bot.lua
            subPath: detect_bot.lua
            readOnly: true
          - name: live-robots-txt-volume
            mountPath: /usr/share/nginx/html/robots.txt
            subPath: robots.txt
            readOnly: true
          - name: live-robots-txt-volume
            mountPath: /etc/nginx/live_robots.txt
            subPath: robots.txt
            readOnly: true
          - name: dhparam-volume
            mountPath: /etc/nginx/ssl/dhparam.pem
            subPath: dhparam.pem
            readOnly: true
          - name: tls-secret-volume
            mountPath: /etc/nginx/ssl
            readOnly: true
          - name: archives-volume
            mountPath: /usr/share/nginx/html/archives/
            readOnly: true
          - name: log-volume # Nginx needs to write logs
            mountPath: /var/log/nginx
          - name: error-pages-volume
            mountPath: /usr/share/nginx/html/errors
            readOnly: true
        livenessProbe:
          tcpSocket: { port: http }
          initialDelaySeconds: 10
          periodSeconds: 15
        readinessProbe:
          httpGet: { path: /, port: http, scheme: HTTP }
          initialDelaySeconds: 5
          periodSeconds: 10
      volumes:
        # ... (rest of volumes from k8s_nginx_deployment_namespaced) ...
        - name: nginx-config-volume
          configMap:
            name: nginx-config
        - name: dhparam-volume
          configMap:
            name: dhparam-config
        - name: error-pages-volume
          configMap:
            name: nginx-error-pages
        - name: tls-secret-volume
          secret:
            secretName: tls-secret
        - name: archives-volume
          persistentVolumeClaim:
            claimName: archives-pvc
        - name: log-volume # Nginx needs to write logs here
          emptyDir: {}
        - name: live-robots-txt-volume
          configMap:
            name: live-robots-txt-config
